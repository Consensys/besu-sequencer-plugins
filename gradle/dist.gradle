import de.undercouch.gradle.tasks.download.Download

import java.text.SimpleDateFormat

/*
 * Copyright Consensys Software Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

tasks.register('sourcesJar', Jar) {
  dependsOn classes
  archiveClassifier = 'sources'
  from sourceSets.main.allSource
}

tasks.register('javadocJar', Jar) {
  dependsOn javadoc
  archiveClassifier = 'javadoc'
  from javadoc.destinationDir
}

tasks.register('downloadLatestLineaBesu', Download) {
  src rootProject.besuUrl
  dest new File(buildDir, rootProject.besuFilename)
  onlyIfModified true
}

jar {
  dependsOn downloadLatestLineaBesu

  archiveBaseName = distributionIdentifier

  manifest {
    attributes(
      'Specification-Title': archiveBaseName.get(),
      'Specification-Version': rootProject.version,
      'Implementation-Title': archiveBaseName.get(),
      'Implementation-Version': calculateVersion()
    )
  }

  from { configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }
  exclude 'META-INF/*.RSA', 'META-INF/*.SF', 'META-INF/*.DSA'
  duplicatesStrategy(DuplicatesStrategy.INCLUDE)
}

// Takes the version, and if -SNAPSHOT is part of it replaces SNAPSHOT
// with the git commit version.
def calculateVersion() {
  String version = rootProject.version
  if (version.endsWith("-SNAPSHOT")) {
    version = version.replace("-SNAPSHOT", "-dev-${getCheckedOutGitCommitHash()}")
  }

  return version
}

static def getCheckedOutGitCommitHash() {
    def hashLength = 8
    "git rev-parse HEAD".execute().text.take(hashLength)
}

tasks.register('distTar', Tar) {
  dependsOn jar
  dependsOn downloadLatestLineaBesu

  from(tarTree(downloadLatestLineaBesu.dest), {
    eachFile { path = path.replaceFirst(rootProject.besuIdentifier, '') }
    includeEmptyDirs = false
    exclude "**/LICENSE"
  })

  from(configurations.installedJars) {
    into "plugins"
    exclude "**/common*.jar"
  }

  into besuPluginsIdentifier
  archiveBaseName = distributionIdentifier
  compression = Compression.GZIP
  archiveExtension = 'tar.gz'

  exclude 'META-INF/*.RSA', 'META-INF/*.SF', 'META-INF/*.DSA'
  duplicatesStrategy(DuplicatesStrategy.INCLUDE)
}

tasks.register('installDist', Copy) {
  dependsOn distTar

  from(tarTree(distTar.outputs.getFiles().getSingleFile()), {
    eachFile { path = path.replaceFirst(besuPluginsIdentifier, distributionIdentifier) }
    includeEmptyDirs = false
  })
  into "$buildDir/distributions/install"
  duplicatesStrategy(DuplicatesStrategy.INCLUDE)
}

tasks.register('distZip', Zip) {
  dependsOn installDist

  archiveBaseName = distributionIdentifier
  from installDist.outputs.getFiles()
  archiveBaseName
  setArchiveExtension 'zip'
  duplicatesStrategy(DuplicatesStrategy.INCLUDE)
}

tasks.register("copyPluginJar") {
  dependsOn installDist

  doLast {
    def copyInto = rootProject.besuPluginDir
    def copyFrom = new File("${project(":arithmetization").buildDir}/libs")

    copy {
      from copyFrom.toString()
      into copyInto.toString()
      include '*.jar'
    }
  }
}

tasks.register('deployPlugins', Copy) {
  dependsOn jar
  dependsOn installDist

  from(configurations.installedJars) {
    into new File(distributionIdentifier, "plugins")
    exclude "**/common*.jar"
  }

  into installDist.destinationDir
}

// rename the top level dir from sequencer-<version> to sequencer and this makes it really
// simple for use in docker
task dockerDistUntar {
  dependsOn distTar
  dependsOn distZip
  def dockerBuildDir = "${rootDir}/build/docker-sequencer/"
  def distTarFile = distTar.outputs.files.singleFile
  def distTarFileName = distTar.outputs.files.singleFile.name.replace(".tar.gz", "")
  println("tar file name --> ${dockerBuildDir}/${distTarFileName}")

  doFirst {
    new File(dockerBuildDir).mkdir()
    copy {
      from tarTree(distTarFile)
      into(dockerBuildDir)
    }
    project.delete(files("${dockerBuildDir}/sequencer"))
    file("${dockerBuildDir}/${distTarFileName}").renameTo("${dockerBuildDir}/sequencer")
  }
}

def dockerBuildVersion = project.hasProperty('release.releaseVersion') ? project.property('release.releaseVersion') : "${rootProject.version}"
def dockerOrgName = project.hasProperty('dockerOrgName') ? project.getProperty("dockerOrgName") : "consensys"
def dockerArtifactName = project.hasProperty("dockerArtifactName") ? project.getProperty("dockerArtifactName") : "linea-sequencer"
def dockerImageName = "${dockerOrgName}/${dockerArtifactName}"
def dockerVariants = project.hasProperty("dockerVariants") ? project.getProperty("dockerVariants").split(",") : [
        "graalvm",
        "openjdk-latest"
]
def archVariants = ["amd64", "arm64"]

task dockerDist {
  dependsOn dockerDistUntar
  inputs.dir("${rootDir}/build/docker-sequencer/")
  def dockerBuildDir = "${rootDir}/build/docker-sequencer/"

  doLast {
    println("${rootDir}")
    for (def jvmVariant in dockerVariants) {
      println("${rootDir}/docker/${jvmVariant}/Dockerfile")
      copy {
        from file("${rootDir}/docker/${jvmVariant}/Dockerfile")
        into(dockerBuildDir)
      }
      exec {
        def image = "${dockerImageName}:${dockerBuildVersion}-${jvmVariant}"
        def dockerPlatform = ""
        if (project.hasProperty('docker-platform')){
          dockerPlatform = "--platform ${project.getProperty('docker-platform')}"
          println "Building for platform ${project.getProperty('docker-platform')}"
        }
        executable "sh"
        workingDir dockerBuildDir
        args "-c", "docker build ${dockerPlatform} --build-arg BUILD_DATE=${buildTime()} --build-arg VERSION=${dockerBuildVersion} --build-arg VCS_REF=${getCheckedOutGitCommitHash()} -t ${image} ."
      }
    }

    // tag the "default" (which is the variant in the zero position)
    exec {
      executable "sh"
      args "-c", "docker tag '${dockerImageName}:${dockerBuildVersion}-${dockerVariants[0]}' '${dockerImageName}:${dockerBuildVersion}'"
    }
    // create a static tag for the benchmark target
    exec {
      executable "sh"
      args "-c", "docker tag '${dockerImageName}:${dockerBuildVersion}-${dockerVariants[0]}' '${dockerImageName}:benchmark'"
    }
  }
}

task dockerTest {
  dependsOn dockerDist
  def dockerReportsDir = "docker/reports/"

  doFirst {
    new File(dockerReportsDir).mkdir()
  }

  doLast {
    def architecture = System.getenv('architecture')
    for (def variant in dockerVariants) {
      exec {
        def image = project.hasProperty('release.releaseVersion') ? "${dockerImageName}:" + project.property('release.releaseVersion') : "${dockerImageName}:${project.version}"
        workingDir "${projectDir}/docker/${variant}"
        executable "sh"
        args "-c", "architecture=${architecture} bash ../test.sh ${image}-${variant}"
      }
    }
  }
}

task dockerUpload {
  dependsOn dockerDist
  def architecture = System.getenv('architecture')
  def image = "${dockerImageName}:${dockerBuildVersion}"
  def tags = []

  if (!isInterimBuild(dockerBuildVersion)) {
    // if this is a release build, upload the version and latest tags
    logger.quiet("uploading release build")
    tags.add("${dockerImageName}:" + dockerBuildVersion)
    tags.add("${dockerImageName}:latest")
  } else {
    // otherwise, upload as develop
    logger.quiet("uploading develop build")
    tags.add("${dockerImageName}:develop")
  }

  doLast {
    exec {
      def archImage = "${image}-${architecture}"

      logger.quiet("architecture: $architecture")
      logger.quiet("image: $image")
      logger.quiet("tags: $tags")
      logger.quiet("archImage: $archImage")

      def cmd = "true"
      tags.each { tag -> cmd += " && docker tag '${image}' '${tag.trim()}-${architecture}' && docker push '${tag.trim()}-${architecture}'" }
      executable "sh"
      args "-c", cmd
    }
  }
}

task dockerManifest {
  def tags = []

  if (!isInterimBuild(dockerBuildVersion)) {
    // if this is a release, create manifests for the version and latest tags
    tags.add("${dockerImageName}:" + dockerBuildVersion)
    tags.add("${dockerImageName}:latest")
  } else {
    // otherwise, create manifest for develop
    tags.add("${dockerImageName}:develop")
  }

  doLast {
    for (baseTag in tags) {

      exec {
        def targets = ""
        archVariants.forEach { arch -> targets += "'${baseTag}-${arch}' " }
        def cmd = "docker manifest create '${baseTag}' ${targets} && docker manifest push '${baseTag}'"
        executable "sh"
        args "-c", cmd
      }
    }
  }
}

def isInterimBuild(dockerBuildVersion) {
  // any build version that is not major.minor.patch is treated as an interim build:
  return !(dockerBuildVersion ==~ /[0-9]+\.[0-9]+\.[0-9]+/)
}

def buildTime() {
  def df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm'Z'")
  df.setTimeZone(TimeZone.getTimeZone("UTC"))
  return df.format(new Date())
}
